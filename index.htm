<html>

<head>


    <!-- special thanks to https://github.com/RasmusFonseca/d3RangeSlider -->
    <script src="https://d3js.org/d3.v5.min.js"></script>

    <!---Imports d3 and topojson --->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <style>
        svg#mapsvg {
            fill: None;
        }

        #type-selection input[type='checkbox']:disabled+label {
            color: #999;

            cursor: not-allowed;
        }
    </style>

</head>

<body>
    <div id="left_panel" style="float:left; width:400px;">
        <svg id="ratingsvg" height="20" width="250"></svg>
        <div id="slider-container"></div>
        <!-- <svg id="neighborsvg" height="20" width="250"></svg> -->
        <div id="type-selection">
            <div>Select Types:</div>
            <!-- "Select All" checkbox -->
            <input type="checkbox" id="select-all" checked> <label for="select-all">Select All</label><br>

            <!-- Dynamically populate types as checkboxes -->
        </div>

    </div>
    <div id="contents" style="float:left; width:400px;">
        <svg id="mapsvg" height="600" width="600"></svg>
    </div>

    <div id="contents" style="float:right; width:650px;">
        <svg id="listsvg" height="6000" width="600"></svg>
    </div>

    <script>
        const mapsvg = d3.select("svg#mapsvg");
        width = mapsvg.attr("width");
        height = mapsvg.attr("height");
        const margin = { top: 10, right: 10, bottom: 10, left: 10 };
        const mapWidth = width - margin.left - margin.right;
        const mapHeight = height - margin.top - margin.bottom;

        const ratingsvg = d3.select("svg#ratingsvg");
        ratingwidth = ratingsvg.attr("width");
        ratingheight = ratingsvg.attr("height");
        const ratingWidth = ratingwidth - margin.left - margin.right;
        const ratingHeight = ratingheight - margin.top - margin.bottom;

        ratingsvg.append("text")
            .attr("class", "rating-label")
            .attr("x", 0)
            .attr("y", 15)
            .attr("text-anchor", "right")
            .style("fill", "black")
            .text("Range of ratings displayed");

        const listsvg = d3.select("svg#listsvg");
        listwidth = listsvg.attr("width");
        listheight = listsvg.attr("height");
        const listWidth = listwidth - margin.left - margin.right;
        const listHeight = listheight - margin.top - margin.bottom;


        const requestData = async function () {
            const bostonjson = await d3.json("./boston.topo.json")
            // console.log(bostonjson);
            var neigh = topojson.feature(bostonjson, bostonjson.objects.boston)
            var neighMesh = topojson.mesh(bostonjson, bostonjson.objects.boston)
            // console.log("sadge")
            // console.log(neigh)
            var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], neigh);
            var path = d3.geoPath().projection(projection);

            let bostonmap = mapsvg.append("g").attr("id", "bostonmap");
            let neighborPaths = bostonmap.selectAll("path.neighbors").data(neigh.features)
                .join("path")
                .attr("class", "neighbors")
                .attr("d", path)
                .style("fill", "lightgray");

            // console.log(neighMesh)
            let neighborPath = bostonmap.append("path").datum(neighMesh)
                .attr("class", "outline")
                .attr("d", path)
                .style("stroke", "white")
                .attr("class", "neighbor-outline")
                .style("stroke-width", 1);


            d3.csv('./yelp_boston.csv', d3.autoType)
                .then((data) => {
                    // console.log(data)

                    var bostonPoints = []

                    data.forEach(function (point) {
                        var projectedPoint = projection([point.longitude, point.latitude]);

                        var pointInNeighborhood = false;
                        neigh.features.forEach(function (neighborhood) {
                            var pathGenerator = d3.geoPath().projection(projection);
                            if (d3.geoContains(neighborhood, [point.longitude, point.latitude])) {
                                pointInNeighborhood = true;
                            }
                        });

                        //point is in boston map
                        if (pointInNeighborhood) {
                            bostonPoints.push(point);
                        }
                    });

                    searchExtent = []
                    for (let i = 0; i < bostonPoints.length; i++) {
                        if (searchExtent.indexOf(bostonPoints[i]['search category']) === -1) {
                            searchExtent.push(bostonPoints[i]['search category']);
                        }
                    }
                    console.log("searchextent")
                    console.log(searchExtent)
                    searchScale = d3.scaleOrdinal().domain(searchExtent).range(d3.schemeTableau10)

                    const revExtent = d3.extent(data, d => d['review_count']);
                    const revScale = d3.scaleLinear().domain(revExtent).range([0.3, 0.5]);

                    const ratingExtent = d3.extent(data, d => d['rating']);
                    const ratingScale = d3.scaleLinear().domain(ratingExtent).range([5, 10]);


                    // console.log(bostonPoints)


                    const typeSelectionDiv = d3.select("#type-selection");
                    console.log("searchExtent")
                    console.log(searchExtent)
                    
                    searchExtent.forEach(function(type) {
                        var checkboxLabel = typeSelectionDiv.append("label")
                                            .attr("style", "display: block;"); // Display checkboxes in a block for better readability

                        checkboxLabel.append("input")
                                    .attr("type", "checkbox")
                                    .attr("id", type.replace(/\s+/g, '-').toLowerCase()) // Create a compliant ID by replacing spaces with dashes and lowercasing
                                    .attr("value", type)
                                    .attr("checked", true); // Start with all checkboxes checked

                        checkboxLabel.append("span")
                                    .text(type); // Use a span to insert text next to checkbox
                    });

                    var selectAllCheckbox = d3.select("#select-all");
                    var selectedTypes = [];
                    d3.selectAll("#type-selection input[type='checkbox']").each(function () {
                        if (this.checked && this.id !== 'select-all') {
                            // console.log(this)
                            selectedTypes.push(this.value);
                        }
                    });

                    selectAllCheckbox.on("change", function () {
                        updateCircles(bostonPoints, ranges, selectedTypes, k);
                    });
                    d3.selectAll("#type-selection input[type='checkbox']").property("checked", true);

                    const numTypes = searchExtent.length;
                    console.log("lenght")
                    console.log(selectedTypes)
                    d3.selectAll("#type-selection input[type='checkbox']")
                        .on("change", function () {
                            updateCircles(bostonPoints, ranges, selectedTypes, k);
                        });

                    var circles = bostonmap.selectAll("circle").data(bostonPoints)
                        .join("circle")
                        .attr("cx", d => projection([d['longitude'], d['latitude']])[0])
                        .attr("cy", d => projection([d['longitude'], d['latitude']])[1])
                        .attr("r", d => ratingScale(d['rating']))
                        .attr("opacity", d => revScale(d['review_count']))
                        .attr("fill", d => searchScale(d['search category']))
                        .on("mouseover", overfn)
                        .on("mouseout", outfn);

                    var zoom = d3.zoom()
                        .scaleExtent([1, 10])
                        .on("zoom", func);

                    mapsvg.call(zoom);
                    mapsvg.call(zoom.transform, d3.zoomIdentity)
                    var k = 1;
                    function func({ transform }) {
                        bostonmap.attr("transform", transform.toString());
                        bostonmap.select(".neighbor-outline")
                            .style("stroke-width", 1 / transform.k);
                        circles = bostonmap.selectAll("circle")
                            .attr("r", d => ratingScale(d['rating']) / transform.k)
                        // console.log(transform.k)
                        k = transform.k
                    }

                    listsvg.append("text")
                        .attr("class", "list-title")
                        .attr("x", 10)
                        .attr("y", 20)
                        .attr("text-anchor", "left")
                        .style("font-weight", "bold")
                        .text("Name");

                    listsvg.append("text")
                        .attr("class", "list-title")
                        .attr("x", 300)
                        .attr("y", 20)
                        .attr("text-anchor", "left")
                        .style("font-weight", "bold")
                        .text("Rating");

                    listsvg.append("text")
                        .attr("class", "list-title")
                        .attr("x", 370)
                        .attr("y", 20)
                        .attr("text-anchor", "left")
                        .style("font-weight", "bold")
                        .text("Number of reviews");

                    const ydict = new Map();

                    console.log(bostonPoints)
                    for (q = 0; q < bostonPoints.length; q++) {

                        ydict.set(bostonPoints[q].name, 45 + 20 * q)

                        listsvg.append("text")
                            .attr("class", "locations-list")
                            .attr("x", 10)
                            .attr("y", 45 + 20 * q)
                            .attr("text-anchor", "left")
                            .text(bostonPoints[q].name);

                        listsvg.append("text")
                            .attr("class", "locations-list")
                            .attr("x", 300)
                            .attr("y", 45 + 20 * q)
                            .attr("text-anchor", "left")
                            .text(bostonPoints[q].rating);

                        listsvg.append("text")
                            .attr("class", "locations-list")
                            .attr("x", 370)
                            .attr("y", 45 + 20 * q)
                            .attr("text-anchor", "left")
                            .text(bostonPoints[q]["review_count"]);
                    }


                    function overfn(event, d) {
                        console.log(this)
                        console.log(d)
                        d3.select(this)
                            .attr("stroke", "black")
                            .attr("stroke-width", 2 / k);

                        // atempting to highlight words
                        listsvg.append('rect')
                            .attr("x", 1)
                            .attr("y", ydict.get(d['name']) - 15)
                            .attr("width", 600)
                            .attr("height", 15)
                            .attr("fill", "yellow")
                            .attr("opacity", 0.2);

                    }

                    function outfn(event, d) {
                        d3.select(this)
                            .attr("stroke", "none")

                        d3.selectAll("rect")
                            .remove();
                    }



                    function updateCircles(data, range, selectedTypes, k) {


                        console.log(selectAllCheckbox.property("checked"))
                        if (selectAllCheckbox.property("checked")) {
                            d3.selectAll("#type-selection input[type='checkbox']").property("checked", true);
                        }

                        d3.selectAll("#type-selection input[type='checkbox']").each(function () {

                            if (this.checked && (this.id !== 'select-all') && !selectedTypes.includes(this.value)) {
                                selectedTypes.push(this.value);
                            }
                            else if (!this.checked && this.id !== 'select-all' && selectedTypes.includes(this.value)) {
                                selectedTypes = selectedTypes.filter(item => item !== this.value);
                            };
                        });

                        // console.log(selectedTypes)
                        filteredData = data.filter(d => (d.rating >= range[0]) && (d.rating <= range[1]) && (selectedTypes.indexOf(d["search category"]) !== -1));

                        // console.log(filteredData);

                        var removedText = d3.selectAll(".locations-list")
                            .remove();

                        for (q = 0; q < filteredData.length; q++) {
                            ydict.set(filteredData[q].name, 45 + 20 * q)

                            listsvg.append("text")
                                .attr("class", "locations-list")
                                .attr("x", 10)
                                .attr("y", 45 + 20 * q)
                                .attr("text-anchor", "left")
                                .text(filteredData[q].name);

                            listsvg.append("text")
                                .attr("class", "locations-list")
                                .attr("x", 300)
                                .attr("y", 45 + 20 * q)
                                .attr("text-anchor", "left")
                                .text(filteredData[q].rating);

                            listsvg.append("text")
                                .attr("class", "locations-list")
                                .attr("x", 370)
                                .attr("y", 45 + 20 * q)
                                .attr("text-anchor", "left")
                                .text(filteredData[q]["review_count"]);
                        }

                        circles = bostonmap.selectAll("circle")
                            .data(filteredData)
                            .attr("cx", d => projection([d['longitude'], d['latitude']])[0])
                            .attr("cy", d => projection([d['longitude'], d['latitude']])[1])
                            .attr("r", d => ratingScale(d['rating']) / k)
                            .attr("opacity", d => revScale(d['review_count']))
                            .attr("fill", d => searchScale(d['search category']))
                            .on("mouseover", overfn)
                            .on("mouseout", outfn);

                        circles.exit().remove();

                        circles.enter()
                            .append("circle")
                            .attr("cx", d => projection([d['longitude'], d['latitude']])[0])
                            .attr("cy", d => projection([d['longitude'], d['latitude']])[1])
                            .attr("r", d => ratingScale(d['rating']) / k)
                            .attr("opacity", d => revScale(d['review_count']))
                            .attr("fill", d => searchScale(d['search category']))
                            .on("mouseover", overfn)
                            .on("mouseout", outfn);
                    }

                })
        }

        requestData();

    </script>

</body>